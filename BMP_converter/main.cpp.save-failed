/* Zamiana plików bmp do skali szarosci */
/* www.algorytm.org */

#include <stdio.h>
#include <windows.h>
#include <iostream>

using namespace std;

/* File Header */
typedef struct BMPFILEHEADER {
        short type;
        int fileSize;
        short reserved0;
        short reserved1;
        int dataOffset;
};

/* Info Header */
typedef struct BMPINFOHEADER {
        int hdrSize;
        int width;
        int height;
        short planes;
        short depth;
        int compression;
        int bmpDataSize;
        int hResolution;
        int vResolution;
        int nColors;
        int nImportantColors;
} ;

typedef struct Pixel24 {
      unsigned char R;
      unsigned char G;
      unsigned char B;
     } ;

int main(int argc, char *argv[], char *envp[])
{
    FILE *plik, *plik2;
    BMPFILEHEADER FileInfo;
    BMPINFOHEADER PictureInfo;
    unsigned long long i, j;
    int xx;
    char szary;
    int padding;
    //char** grayPicture;
    Pixel24** pixmap2;

    if(plik = fopen("orangutan.bmp","rb"))
    {
          //wczytanie nagłówków BMP
          fread(&FileInfo.type,2,1,plik);
          fread(&FileInfo.fileSize,4,1,plik);
          fread(&FileInfo.reserved0,2,1,plik);
          fread(&FileInfo.reserved1,2,1,plik);
          fread(&FileInfo.dataOffset,4,1,plik);
          fread(&PictureInfo.hdrSize,4,1,plik);
          fread(&PictureInfo.width,4,1,plik);
          fread(&PictureInfo.height,4,1,plik);
          fread(&PictureInfo.planes,2,1,plik);
          fread(&PictureInfo.depth,2,1,plik);
          fread(&PictureInfo.compression,4,1,plik);
          fread(&PictureInfo.bmpDataSize,4,1,plik);
          fread(&PictureInfo.hResolution,4,1,plik);
          fread(&PictureInfo.vResolution,4,1,plik);
          fread(&PictureInfo.nColors,4,1,plik);
          fread(&PictureInfo.nImportantColors,4,1,plik);

          delete xx;

          cout << char(FileInfo.type) << endl << FileInfo.fileSize << endl << FileInfo.reserved0 << endl << FileInfo.reserved1 << endl << FileInfo.dataOffset << endl;
          cout << endl << PictureInfo.hdrSize << endl << PictureInfo.width << endl << PictureInfo.height << endl << PictureInfo.planes << endl;
          cout << PictureInfo.depth << endl << PictureInfo.compression << endl << PictureInfo.bmpDataSize << endl << PictureInfo.hResolution << endl;
          cout << PictureInfo.vResolution << endl << PictureInfo.nColors << endl << PictureInfo.nImportantColors << endl;

           //alokacja pamięci pod pixmape
           //Pixel24 pixmap[100][100];
           pixmap2 = new Pixel24 *[PictureInfo.height];
           cout << "We are here" << endl;
           //pixmap = malloc(sizeof(Pixel24*) * PictureInfo.height);
           for(i = 0; i < PictureInfo.height; i++)
                pixmap2[i] = new Pixel24 [PictureInfo.width];
            cout << "We are here2" << endl;
           //obliczenie wyrównania wiersza do wielokrotności 4B
           padding = (PictureInfo.width*3)%4 ?
                                             4-(PictureInfo.width*3)%4
                                             :
                                             0;
           //wczytanie bitmapy do pix mapy :P
           fseek(plik, FileInfo.dataOffset,SEEK_SET);
           for(i = 0; i < PictureInfo.height; i++, fseek(plik, padding, SEEK_CUR))
                 for(j = 0; j < PictureInfo.width; j++)
                 {
                       pixmap2[i][j].B = fgetc(plik);
                       pixmap2[i][j].G = fgetc(plik);
                       pixmap2[i][j].R = fgetc(plik);
                 }
           //operacje na nowym pliku
           if(plik2 = fopen("nowy3.bmp","wb"))
           {        //kopiowanie pliku
                    fseek(plik, 0, SEEK_END);
                    j = ftell(plik);
                    fseek(plik, 0, SEEK_SET);
                    for(i = 0; i < j; i++)
                          fputc(fgetc(plik), plik2);
                    //zapis bitmapy + konwersja do szarości
                    fseek(plik2, FileInfo.dataOffset, SEEK_SET);
                    for(i = 0; i < PictureInfo.height; i++, fseek(plik2, padding, SEEK_CUR))
                          for(j = 0; j < PictureInfo.width; j++)
                          {
                                szary = (char)(0.229*pixmap2[i][j].R + 0.587*pixmap2[i][j].G + 0.114*pixmap2[i][j].B);
                                fputc(szary, plik2);
                                fputc(szary, plik2);
                                fputc(szary, plik2);
                          }
                    fclose(plik2);
           }           else
                            cout << "niepowodzenie tworzenia pliku";
           //zwolnienie pamięci pixmapy
           for(i = 0; i<PictureInfo.height; i++)
                 delete (pixmap2[i]);
           delete(pixmap2);
           //zamkniecie plików
           fclose(plik);
    }
    else
        cout << "blad odczytu pliku";

    cout << "zakonczono!";
    system("pause");
return 0;
}

